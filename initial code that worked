# Geometry-driven layout Streamlit demo (single file)
# ------------------------------------------------
# Features
# - Normalized coordinates [0..1] for each slot (id,x,y,w,h)
# - Absolute-positioned boxes rendered in a single HTML canvas
# - Thin black borders, padding, optional grid overlay
# - Sidebar JSON editor with Apply + Snap-to-grid (0.01)
# - Font/marker scaling by slot area
# - Simple mobile fallback: stack all slots when width < 700px
# - Fake data: KPI row, line chart, bar chart, data table
# - No external files required
#
# Run:
#   pip install streamlit plotly pandas numpy
#   streamlit run geometry_streamlit_app.py

import json
import uuid
import numpy as np
import pandas as pd
import plotly.express as px
import streamlit as st
from streamlit.components.v1 import html as st_html

st.set_page_config(page_title="Geometry Layout Demo", layout="wide", initial_sidebar_state="expanded")

# ---------------------------
# Default layout (normalized)
# ---------------------------
DEFAULT_LAYOUT = {
    "meta": {"name": "demo_layout", "padding_px": 8, "show_grid": True, "base_area_px": 300 * 200},
    "slots": [
        {"id": "kpi_row", "x": 0.02, "y": 0.02, "w": 0.96, "h": 0.12, "border": True},
        {"id": "chart_A", "x": 0.02, "y": 0.16, "w": 0.46, "h": 0.38, "border": True},
        {"id": "chart_B", "x": 0.52, "y": 0.16, "w": 0.46, "h": 0.38, "border": True},
        {"id": "table_C", "x": 0.02, "y": 0.56, "w": 0.96, "h": 0.40, "border": True}
    ]
}

# ---------------------------
# Sidebar: controls + JSON editor
# ---------------------------
st.sidebar.header("Layout Editor / Controls")

if "layout" not in st.session_state:
    # deep copy-like initialization
    st.session_state.layout = json.loads(json.dumps(DEFAULT_LAYOUT))

layout_text = st.sidebar.text_area(
    "Edit layout JSON (normalized 0..1)",
    value=json.dumps(st.session_state.layout, indent=2),
    height=360,
)

c1, c2 = st.sidebar.columns(2)
with c1:
    apply_btn = st.button("Apply layout")
with c2:
    reset_btn = st.button("Reset to default")

snap_to_grid = st.sidebar.checkbox("Snap to 0.01 grid on apply", value=True)
show_grid_overlay = st.sidebar.checkbox("Overlay grid on canvas", value=True)

st.sidebar.divider()
st.sidebar.caption("Breakpoint: viewport width < 700px → stacked layout (mobile fallback)")

if reset_btn:
    st.session_state.layout = json.loads(json.dumps(DEFAULT_LAYOUT))
    st.experimental_rerun()

if apply_btn:
    try:
        new_layout = json.loads(layout_text)
        assert isinstance(new_layout.get("slots"), list), "Missing 'slots' list"
        # optional snap
        if snap_to_grid:
            for s in new_layout["slots"]:
                for k in ("x", "y", "w", "h"):
                    if k in s:
                        s[k] = max(0.0, min(1.0, round(float(s[k]), 2)))
        st.session_state.layout = new_layout
        st.success("Layout applied.")
    except Exception as e:
        st.error(f"Invalid JSON / schema: {e}")

# ---------------------------
# Fake data
# ---------------------------
@st.cache_data
def make_fake_timeseries(n=200, seed=42):
    rng = np.random.default_rng(seed)
    ts = pd.date_range("2025-01-01", periods=n, freq="H")
    a = np.cumsum(rng.normal(0, 1, n)) + 50
    b = np.cumsum(rng.normal(0, 1, n)) + 20
    return pd.DataFrame({"time": ts, "series_A": a, "series_B": b})

@st.cache_data
def make_fake_table(n=40, seed=123):
    rng = np.random.default_rng(seed)
    return pd.DataFrame({
        "order_id": np.arange(1000, 1000 + n),
        "value": np.round(rng.random(n) * 1000, 2),
        "category": rng.choice(["X", "Y", "Z"], n)
    })

ts = make_fake_timeseries()
tbl = make_fake_table()

# Plotly figures → JSON for client-side rendering
figA = px.line(ts.tail(120), x="time", y="series_A", title="Series A (last 120 hours)")
figB = px.bar(ts.tail(40), x="time", y="series_B", title="Series B (last 40 hours)")

figA_json = json.loads(figA.to_json())
figB_json = json.loads(figB.to_json())

# KPI values
kpis = {
    "ActiveUsers": int(5000 + np.random.randint(-200, 200)),
    "Orders": int(300 + np.random.randint(-50, 50)),
    "Conversion%": float(np.round(2.5 + np.random.random(), 2)),
}

# Table HTML (escape backticks)
table_html = tbl.to_html(index=False, classes="table-class", justify="center").replace("`", "\u0060")

# ---------------------------
# Canvas HTML/JS
# ---------------------------
component_id = "comp-" + uuid.uuid4().hex[:8]
layout = st.session_state.layout
meta = layout.get("meta", {})
padding_px = int(meta.get("padding_px", 8))
base_area_px = int(meta.get("base_area_px", 300 * 200))

html_template = """
<!doctype html>
<html>
<head>
  <meta charset=\"utf-8\" />
  <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>
  <style>
    html,body { margin:0; padding:0; height:100%; }
    .canvas-__CID__ {
      position: relative;
      width: 100%;
      height: 85vh; /* leave room for Streamlit header */
      overflow: hidden;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.01));
    }
    .slot {
      position: absolute;
      box-sizing: border-box;
      overflow: hidden;
      background-clip: padding-box;
    }
    .slot .slot-inner {
      width: 100%;
      height: 100%;
      padding: __PADDING__px;
      box-sizing: border-box;
      overflow: auto;
      border-radius: 6px;
      background: rgba(255,255,255,0.01);
    }
    .kpi-card {
      display: flex;
      align-items: center;
      justify-content: space-around;
      gap: 12px;
      height: 100%;
    }
    .kpi-item { text-align: center; font-family: Arial, sans-serif; }
    .kpi-label { color:#333; opacity:0.8; }
    .kpi-value { font-weight: 700; }
    .table-class { width:100%; border-collapse: collapse; font-family: Arial, sans-serif; font-size:12px; }
    .table-class th, .table-class td { border: 1px solid #ddd; padding: 6px; }
    .grid-overlay {
      position:absolute; inset:0; pointer-events:none;
      background-image: linear-gradient(to right, rgba(0,0,0,0.06) 1px, transparent 1px),
                        linear-gradient(to bottom, rgba(0,0,0,0.06) 1px, transparent 1px);
      background-size: 40px 40px;
      opacity: 0.5;
    }
    /* Mobile fallback: slot borders still visible */
  </style>
</head>
<body>
  <div id=\"canvas\" class=\"canvas-__CID__\"></div>
  <script>
    (function() {
      const LAYOUT = __LAYOUT__;
      const FIGA   = __FIGA__;
      const FIGB   = __FIGB__;
      const KPIS   = __KPIS__;
      const THTML  = `__THTML__`;
      const BASE_AREA = __BASEAREA__;
      const SHOW_GRID = __SHOWGRID__;

      const canvas = document.getElementById('canvas');
      const rect = canvas.getBoundingClientRect();
      let Vw = rect.width;
      let Vh = rect.height;

      // Mobile fallback: if too narrow, stack all slots
      const useMobile = (Vw < 700);

      if (SHOW_GRID) {
        const grid = document.createElement('div');
        grid.className = 'grid-overlay';
        canvas.appendChild(grid);
      }

      function addSlot(slot, index) {
        const left = Math.round(slot.x * Vw);
        const top  = Math.round(slot.y * Vh);
        const w    = Math.round(slot.w * Vw);
        const h    = Math.round(slot.h * Vh);

        const div = document.createElement('div');
        div.className = 'slot';
        div.style.left = left + 'px';
        div.style.top  = top  + 'px';
        div.style.width= w + 'px';
        div.style.height= h + 'px';
        if (slot.border) div.style.border = '1px solid rgba(0,0,0,0.7)';

        const inner = document.createElement('div');
        inner.className = 'slot-inner';
        inner.id = 'slot-inner-' + slot.id;
        div.appendChild(inner);
        canvas.appendChild(div);

        // scale fonts/markers by area
        const scale = Math.sqrt((w * h) / BASE_AREA);
        const fontSize = Math.max(10, Math.round(14 * scale));
        inner.style.fontSize = fontSize + 'px';

        // render by id
        if (slot.id === 'kpi_row') {
          const card = document.createElement('div');
          card.className = 'kpi-card';
          for (const k of Object.keys(KPIS)) {
            const item = document.createElement('div');
            item.className = 'kpi-item';
            item.innerHTML = `<div class=\"kpi-label\" style=\"font-size:${Math.max(12, fontSize)}px\">${k}</div>` +
                             `<div class=\"kpi-value\" style=\"font-size:${Math.max(18, Math.round(fontSize*1.3))}px\">${KPIS[k]}</div>`;
            card.appendChild(item);
          }
          inner.appendChild(card);
        }
        else if (slot.id === 'chart_A') {
          const plotDiv = document.createElement('div');
          plotDiv.id = 'plot_' + slot.id;
          plotDiv.style.width = '100%';
          plotDiv.style.height = '100%';
          inner.appendChild(plotDiv);
          Plotly.react(plotDiv, FIGA.data, FIGA.layout || {}, {responsive:true});
        }
        else if (slot.id === 'chart_B') {
          const plotDiv = document.createElement('div');
          plotDiv.id = 'plot_' + slot.id;
          plotDiv.style.width = '100%';
          plotDiv.style.height = '100%';
          inner.appendChild(plotDiv);
          Plotly.react(plotDiv, FIGB.data, FIGB.layout || {}, {responsive:true});
        }
        else if (slot.id === 'table_C') {
          inner.innerHTML = THTML;
        }
        else {
          inner.innerHTML = '<div style="padding:8px">Empty slot: ' + slot.id + '</div>';
        }
      }

      if (useMobile) {
        const n = LAYOUT.slots.length;
        const hEach = 1 / n;
        LAYOUT.slots.forEach((s, i) => {
          const stacked = { id: s.id, x: 0, y: i * hEach, w: 1, h: hEach, border: s.border };
          addSlot(stacked, i);
        });
      } else {
        LAYOUT.slots.forEach((s, i) => addSlot(s, i));
      }
    })();
  </script>
</body>
</html>
"""

# Safely substitute tokens without f-strings to avoid brace escaping issues
html_template = (html_template
    .replace("__CID__", component_id)
    .replace("__PADDING__", str(padding_px))
    .replace("__LAYOUT__", json.dumps(layout))
    .replace("__FIGA__", json.dumps(figA_json))
    .replace("__FIGB__", json.dumps(figB_json))
    .replace("__KPIS__", json.dumps(kpis))
    .replace("__THTML__", table_html)
    .replace("__BASEAREA__", str(base_area_px))
    .replace("__SHOWGRID__", "true" if show_grid_overlay else "false")
)


st.title("Geometry‑Driven Boxes — Single‑File Demo")
st.caption("Edit the JSON in the sidebar → Apply. Coordinates are normalized [0..1]. No Streamlit columns used — placement is via geometry only.")

# Render the HTML component
st_html(html_template, height=740, scrolling=True)

st.markdown("---")
st.subheader("Notes")
st.markdown(
    """
- **Normalized coordinates**: `x,y` = top-left, `w,h` = size, all in **[0..1]** relative to the canvas.
- **Snap to grid** (optional): rounds all `x,y,w,h` to **0.01** on Apply.
- **Scaling**: text scales by `sqrt(slot_area / base_area_px)`.
- **Mobile fallback**: when viewport width < 700px, slots are stacked vertically (auto layout).
- **Routing**: slot `id` decides what content is drawn. Add more `elif` branches for new IDs.
- **Self-contained**: fake data + Plotly + table — no external files.
    """
)
